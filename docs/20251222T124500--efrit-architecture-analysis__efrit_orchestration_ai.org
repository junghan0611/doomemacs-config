#+title:      Efrit 아키텍처 분석: 멀티에이전트 오케스트레이션
#+date:       [2025-12-22 Sun 12:45]
#+filetags:   :efrit:orchestration:ai:
#+identifier: 20251222T124500

* 개요

Steve Yegge의 Efrit 아키텍처를 분석하고, 우리 환경에 적용하기 위한 검토 문서.

** 핵심 질문

1. Efrit에서 API 비용이 많이 발생하는가?
2. 작업 에이전트(Claude Code 등)와 Efrit의 관계는?
3. OpenRouter 적용이 필요한가?

* Efrit의 역할: Control Plane

** 아키텍처 원칙

#+begin_quote
*ZERO CLIENT-SIDE INTELLIGENCE*: Efrit is a pure executor that delegates ALL cognitive computation to Claude.
#+end_quote

Efrit은 *순수 실행기*로서:
- 컨텍스트 수집 (버퍼 내용, 파일 목록, 환경 정보)
- 도구 실행 (eval_sexp, shell_exec 등)
- 결과 전달

모든 *인지 작업*은 Claude에 위임:
- 사용자 요청 이해
- 코드 생성
- 작업 순서 결정
- 완료 판단

** 멀티에이전트 환경에서의 위치

#+begin_src text
┌─────────────────────────────────────────────────────────────────┐
│                        CONTROL PLANE                            │
│                          (Emacs)                                │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                       Efrit                              │   │
│  │  - 컨텍스트 제공 (35+ 도구)                               │   │
│  │  - 세션 관리                                              │   │
│  │  - Remote Queue (AI-to-AI 통신)                          │   │
│  │  - 비용 예산 관리 (Circuit Breaker)                       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              ▲                                  │
│                              │ JSON 큐                          │
│                              ▼                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                       EXECUTION PLANE                           │
│                    (터미널 / 에이전트들)                          │
│                                                                 │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐       │
│  │ Claude   │  │ Claude   │  │ Claude   │  │  ...     │       │
│  │ Code #1  │  │ Code #2  │  │ Code #3  │  │ (50개)   │       │
│  │ (vterm)  │  │ (vterm)  │  │ (vterm)  │  │          │       │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘       │
│       │              │              │              │           │
│       └──────────────┴──────────────┴──────────────┘           │
│                        정액제 API                               │
└─────────────────────────────────────────────────────────────────┘
#+end_src

** Steve의 50개 vterm 구조 추정

Steve가 50개 vterm으로 에이전트를 돌린다는 의미:
- 각 터미널: Claude Code 같은 *정액제* AI 에이전트 실행
- Efrit: 그 에이전트들을 *오케스트레이션*
- 비용 분리: 작업 에이전트는 정액제, Efrit은 API 호출

* Efrit 비용 구조 분석

** 비용 제어 메커니즘

=efrit-budget.el= 에서 정의된 기본값:

| 설정 | 기본값 | 설명 |
|------+--------+------|
| efrit-budget-total-target | 100,000 | 세션당 총 토큰 |
| efrit-budget-per-tool-default | 8,000 | Tool 결과당 |
| efrit-budget-response-buffer | 30,000 | 응답 생성용 |
| Circuit Breaker | 30 calls | 세션당 최대 tool 호출 |

** 비용 추정 (Claude Sonnet 4 기준)

- Input: $3/M tokens
- Output: $15/M tokens

| 사용 패턴 | 예상 비용 |
|-----------|-----------|
| 간단한 명령 (efrit-do) | $0.05-0.15 |
| 일반 세션 | $0.15-0.50 |
| 복잡한 작업 | $0.50-1.50 |
| 하루 활발한 사용 | $5-15 |

** 비용 발생 지점

1. *efrit-do*: 자연어 명령 실행 (API 호출)
2. *efrit-chat*: 대화형 세션 (API 호출)
3. *efrit-agent*: 복잡한 작업 (API 호출)
4. *Remote Queue*: AI-to-AI 통신 (API 호출)

* main vs ko 브랜치 비교

** main 브랜치 (upstream)

- 최신 버그 수정
- Agent REPL 개선
- 안정화 중심

** ko 브랜치 (junghan0611/efrit-ko)

추가된 기능:
1. OpenRouter API 지원 (advice 패턴)
2. Project-Wide Awareness 도구들
3. confirm_action tool
4. 한글 문서 (BD-GUIDE-KO.md 등)
5. TROUBLESHOOTING.md, ONBOARDING.md

차이 규모: 약 50개 파일, 수천 줄 변경

** 현재 상태

ko 브랜치는 main보다 뒤처짐 (2025-11-26 마지막 머지)

* OpenRouter 적용 검토

** 현재 상황

- =ai-agent-shell.el= 에 =efrit-api-backend= 설정 존재
- 'anthropic 또는 'openrouter 선택 가능
- 하지만 main 브랜치에는 OpenRouter 지원 없음

** OpenRouter 장점

1. *회사 API 사용*: jhkim2@goqual.com 계정
2. *비용 분산*: 개인 API 부담 감소
3. *다양한 모델*: Claude 외 다른 모델도 사용 가능

** 적용 방안

옵션 A: ko 브랜치 유지
- OpenRouter 패치 사용
- main과 동기화 필요

옵션 B: main에 OpenRouter 패치 포팅
- 최소한의 변경
- Steve 아키텍처 유지

옵션 C: advice 패턴으로 외부 적용
- main 수정 없이
- 설정에서 advice 적용

** 결론: main 브랜치 + Anthropic API 사용

OpenRouter 적용은 advice만으로 불가능. =efrit-common.el= 수정 필수:

| 함수/변수 | 문제점 | advice 가능 |
|-----------+--------+-------------|
| efrit-common--validate-api-key | sk- prefix 강제 | 전체 교체 필요 |
| efrit-common-build-headers | Anthropic 전용 헤더 | 전체 교체 필요 |
| efrit-api-backend | 변수 자체가 없음 | 추가 필요 |

*현재 방침*: main 브랜치 + Anthropic API로 진행
*향후*: OpenRouter 필요 시 ko 브랜치 사용 또는 리베이스

* ko 브랜치 OpenRouter 수정 가이드 (에이전트용)

이 섹션은 향후 OpenRouter 지원이 필요할 때 참고.

** 수정이 필요한 파일

*** 1. efrit-common.el 수정

#+begin_src elisp
;; 1) efrit-api-backend 변수 추가 (defcustom 섹션)
(defcustom efrit-api-backend 'anthropic
  "API backend: 'anthropic or 'openrouter"
  :type '(choice (const anthropic) (const openrouter))
  :group 'efrit)

;; 2) API 키 검증 수정 - sk-or-* 허용
(defun efrit-common--validate-api-key (key)
  (when (or (not (stringp key))
            (string-empty-p key)
            (< (length key) 20))
    (error "Invalid API key"))
  ;; sk- 또는 sk-or- 둘 다 허용 (warning만)
  (unless (or (string-prefix-p "sk-" key)
              (string-match-p "^sk-or-" key))
    (message "Warning: Unknown key format"))
  t)

;; 3) OpenRouter 관련 변수 추가
(defcustom efrit-openrouter-site-url "https://github.com/junghan0611/efrit-ko"
  "OpenRouter HTTP-Referer"
  :type 'string :group 'efrit)

(defcustom efrit-openrouter-site-name "Efrit-KO"
  "OpenRouter X-Title"
  :type 'string :group 'efrit)
#+end_src

*** 2. efrit-openrouter.el 신규 생성

#+begin_src elisp
;;; efrit-openrouter.el --- OpenRouter API support -*- lexical-binding: t; -*-

;; 핵심 기능:
;; 1. 요청 변환: Anthropic → OpenRouter (OpenAI 호환)
;;    - system prompt를 messages 배열 첫 번째로 이동
;;    - tools를 OpenAI function calling 형식으로 변환
;;    - model을 OpenRouter 형식으로 (anthropic/claude-sonnet-4)

;; 2. 응답 변환: OpenRouter → Anthropic
;;    - choices[0].message → content 배열
;;    - tool_calls → tool_use 형식
;;    - finish_reason → stop_reason

;; 3. advice 적용
;;    - efrit-executor--api-request :around advice
;;    - efrit--send-api-request :around advice (chat용)

;; 주요 함수:
(defun efrit-openrouter--convert-request (request-data)
  "Anthropic 요청을 OpenRouter 형식으로 변환")

(defun efrit-openrouter--convert-response (response)
  "OpenRouter 응답을 Anthropic 형식으로 변환")

(defun efrit-openrouter--convert-tools (tools)
  "Anthropic tools를 OpenAI function 형식으로 변환")

(defun efrit-openrouter-enable ()
  "advice 활성화")

(defun efrit-openrouter-disable ()
  "advice 비활성화")
#+end_src

*** 3. 헤더 빌드 함수 수정

#+begin_src elisp
;; efrit-common.el 또는 efrit-api.el
(defun efrit-common-build-headers (api-key)
  (if (eq efrit-api-backend 'openrouter)
      ;; OpenRouter 헤더
      `(("Content-Type" . "application/json")
        ("Authorization" . ,(concat "Bearer " api-key))
        ("HTTP-Referer" . ,efrit-openrouter-site-url)
        ("X-Title" . ,efrit-openrouter-site-name))
    ;; Anthropic 헤더 (기존)
    `(("Content-Type" . "application/json")
      ("anthropic-version" . ,efrit-common-api-version)
      ("x-api-key" . ,api-key)
      ("anthropic-beta" . "max-tokens-3-5-sonnet-2024-07-15"))))
#+end_src

** 변환 로직 요약

*** 요청 변환 (Anthropic → OpenRouter)

| Anthropic | OpenRouter |
|-----------+------------|
| system (별도 필드) | messages[0] role=system |
| tools (Anthropic 형식) | tools (OpenAI function 형식) |
| model: claude-sonnet-4 | model: anthropic/claude-sonnet-4 |

*** 응답 변환 (OpenRouter → Anthropic)

| OpenRouter | Anthropic |
|------------+-----------|
| choices[0].message.content | content[{type:text, text:...}] |
| choices[0].message.tool_calls | content[{type:tool_use, ...}] |
| finish_reason: tool_calls | stop_reason: tool_use |
| finish_reason: stop | stop_reason: end_turn |

** 참고: ko 브랜치 전체 파일

- =lisp/efrit-openrouter.el= (신규, ~280줄)
- =lisp/core/efrit-common.el= (수정, ~50줄 변경)

* Remote Queue: AI-to-AI 통신

** 메커니즘

#+begin_src text
Claude Code (터미널)
       │
       │ JSON 파일 작성
       ▼
~/.efrit/queue/requests/
       │
       │ filenotify 감지
       ▼
Efrit (Emacs)
       │
       │ 처리 후 응답
       ▼
~/.efrit/queue/responses/
       │
       │ 파일 읽기
       ▼
Claude Code (터미널)
#+end_src

** 설정

| 설정 | 기본값 | 설명 |
|------+--------+------|
| efrit-remote-queue-timeout | 30s | 요청 처리 타임아웃 |
| efrit-remote-queue-max-concurrent | 10 | 동시 처리 최대 |
| efrit-remote-queue-cleanup-delay | 300s | 파일 정리 대기 |

* Beads(bd)와의 연동

** 현재 구조

- Efrit에 beads 도구 내장 (beads_ready, beads_create, beads_update 등)
- Claude가 bd 명령을 직접 실행 가능
- VC(VibeCoder)는 별도 CLI로 bd 활용

** 통합 워크플로우

1. =bd ready= 로 작업 가능 이슈 확인
2. Efrit 또는 Claude Code로 작업 수행
3. =bd close= 로 이슈 완료

* 다음 단계

** TODO ai-orchestration.el 생성 [0/4]

- [ ] efrit 조건부 로딩 (site-lisp 패턴)
- [ ] OpenRouter advice 적용 (옵션)
- [ ] 키바인딩 설정
- [ ] beads 연동 유지

** TODO main 브랜치 동기화 검토

- ko 브랜치를 main에 리베이스하거나
- 필요한 패치만 cherry-pick

** TODO 비용 모니터링

- 실제 사용 패턴 측정
- OpenRouter 필요 여부 결정

* 참고 자료

- [[file:20251222T121027--multi-agent-workflow-summary__agents_vc_efrit_bd_terminal_eaf.org][멀티에이전트 워크플로우 정리]]
- [[https://github.com/steveyegge/efrit][Efrit GitHub]]
- [[https://github.com/steveyegge/vc][VC (VibeCoder) GitHub]]
